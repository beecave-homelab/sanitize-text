<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PyScrub WebUI</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="container">
        <header class="app-header">
            <div class="brand">
                <h1>Sanitize Text</h1>
                <p>Scrub PII from text and documents</p>
            </div>
            <div class="header-actions">
                <button id="theme-toggle" aria-label="Toggle dark mode" class="icon-button" title="Toggle dark mode">ðŸŒ™</button>
            </div>
        </header>
        
        <main>
            <div class="card input-card">
                <div class="step-label">Step 1 &middot; Input</div>
                <label for="input-text" class="section-title">Input</label>
                <textarea 
                    id="input-text" 
                    placeholder="Paste or type text to scrubâ€¦"
                    spellcheck="true"
                ></textarea>

                <div id="dropzone" class="dropzone" aria-label="Drag & drop a file here">
                    <div class="dz-instructions">Drop a file here or <label for="upload-file" class="link">browse</label></div>
                    <input id="upload-file" type="file" accept=".txt,.pdf,.doc,.docx,.rtf,.png,.jpg,.jpeg,.tif,.tiff,.bmp,.webp" hidden />
                    <div id="file-pill" class="file-pill" style="display:none;"></div>
                </div>

                <div class="toolbar">
                    <div class="segmented" id="locale-tabs" role="tablist" aria-label="Language">
                        <button class="active" data-value="" role="tab" aria-selected="true">Both</button>
                        <button data-value="en_US" role="tab" aria-selected="false">English</button>
                        <button data-value="nl_NL" role="tab" aria-selected="false">Dutch</button>
                    </div>
                    <div class="actions-bar">
                        <button id="scrub-btn" class="primary">Scrub</button>
                        <button id="download-btn" class="secondary">Download</button>
                    </div>
                </div>
            </div>

            <div class="controls-container">
                <input id="locale" type="hidden" value="" />

                <details class="advanced" id="advanced">
                    <summary>Advanced settings</summary>
                    <div class="step-label step-label-sub">Step 2 &middot; Configure detectors &amp; output</div>
                    <div class="detector-options">
                    <div class="detector-group">
                        <h3>Universal Detectors</h3>
                        <div class="detector-list">
                            {% for key, description in generic_detectors.items() %}
                                <label title="{{ description }}">
                                    <input type="checkbox" name="detector" value="{{ key }}" checked>
                                    {{ key.replace('_', ' ').title() }}
                                </label>
                            {% endfor %}
                        </div>
                    </div>

                    <div class="detector-group" id="en-detectors">
                        <h3>English Detectors</h3>
                        <div class="detector-list">
                            {% for key, description in english_detectors.items() %}
                                <label title="{{ description }}">
                                    <input type="checkbox" name="detector" value="en:{{ key }}" {% if key != 'date_of_birth' %}checked{% endif %}>
                                    {{ key.replace('_', ' ').title() }}
                                </label>
                            {% endfor %}
                        </div>
                    </div>

                    <div class="detector-group" id="nl-detectors">
                        <h3>Dutch Detectors</h3>
                        <div class="detector-list">
                            {% for key, description in dutch_detectors.items() %}
                                <label title="{{ description }}">
                                    <input type="checkbox" name="detector" value="nl:{{ key }}" checked>
                                    {{ key.replace('_', ' ').title() }}
                                </label>
                            {% endfor %}
                        </div>
                    </div>
                    {% if not spacy_available %}
                        <p class="detector-note">Install <code>sanitize-text[spacy]</code> to enable optional spaCy-powered entity detectors.</p>
                    {% endif %}

                    <div class="extra-options">
                    <div class="field">
                        <label for="custom-text">Custom text to detect (optional):</label>
                        <input id="custom-text" type="text" placeholder="e.g. AcmeCorp or Employee ID 1234" />
                    </div>
                    <div class="field-row">
                        <label class="toggle">
                            <input id="cleanup" type="checkbox" checked />
                            Cleanup output
                        </label>
                        <label class="toggle">
                            <input id="verbose" type="checkbox" />
                            Show verbose PII mappings
                        </label>
                    </div>
                    <div class="field-row">
                        <label for="output-format">Output format:</label>
                        <select id="output-format">
                            <option value="txt" selected>TXT</option>
                            <option value="docx">DOCX</option>
                            <option value="pdf">PDF</option>
                        </select>

                        <label for="pdf-mode">PDF mode:</label>
                        <select id="pdf-mode">
                            <option value="pre" selected>Preformatted</option>
                            <option value="para">Paragraph</option>
                        </select>

                        <label for="font-size">Font size:</label>
                        <input id="font-size" type="number" min="6" max="48" value="11" />
                    </div>
                    </div>
                </details>
            </div>

            <div class="card output-card">
                <div class="step-label">Step 3 &middot; Review &amp; export</div>
                <label for="output-text" class="section-title">Output</label>
                <textarea 
                    id="output-text" 
                    readonly 
                    placeholder="Processed text will appear here..."
                ></textarea>
                <details id="verbose-panel" class="verbose-panel" style="display:none;">
                    <summary>PII mappings</summary>
                    <div id="verbose-output" style="white-space: pre-wrap; font-family: monospace; font-size: 0.9rem;"></div>
                </details>
                <div class="output-actions">
                    <div id="result-meta" class="result-meta"></div>
                    <button id="copy-btn" class="secondary" type="button">Copy</button>
                </div>
                <div class="cli-preview" aria-label="CLI equivalent command">
                    <div class="cli-preview-header">
                        <span class="cli-preview-title">CLI equivalent</span>
                        <button id="cli-copy-btn" class="ghost-button" type="button">Copy command</button>
                    </div>
                    <pre id="cli-command" class="cli-command" aria-live="polite">sanitize-text -t &lt;text&gt;</pre>
                </div>
            </div>
        </main>
    </div>

    <script>
        const localeSelect = document.getElementById('locale');
        const enDetectors = document.getElementById('en-detectors');
        const nlDetectors = document.getElementById('nl-detectors');
        const localeTabs = document.getElementById('locale-tabs');
        const dropzone = document.getElementById('dropzone');
        const fileInput = document.getElementById('upload-file');
        const filePill = document.getElementById('file-pill');
        const themeToggle = document.getElementById('theme-toggle');
        const cliCommandEl = document.getElementById('cli-command');
        const cliCopyBtn = document.getElementById('cli-copy-btn');

        function updateDetectorVisibility() {
            const locale = localeSelect.value;
            if (locale === 'en_US') {
                enDetectors.style.display = 'block';
                nlDetectors.style.display = 'none';
            } else if (locale === 'nl_NL') {
                enDetectors.style.display = 'none';
                nlDetectors.style.display = 'block';
            } else {
                enDetectors.style.display = 'block';
                nlDetectors.style.display = 'block';
            }
        }

        localeSelect.addEventListener('change', updateDetectorVisibility);
        updateDetectorVisibility();

        // Segmented locale tabs
        function setLocaleFromTabs(value) {
            localeSelect.value = value || '';
            if (localeTabs) {
                Array.from(localeTabs.querySelectorAll('button')).forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === value);
                    btn.setAttribute('aria-selected', String(btn.dataset.value === value));
                });
            }
            updateDetectorVisibility();
        }
        if (localeTabs) {
            localeTabs.addEventListener('click', (e) => {
                const btn = e.target.closest('button');
                if (!btn) return;
                setLocaleFromTabs(btn.dataset.value || '');
                void updateCliPreview();
            });
            setLocaleFromTabs('');
        }

        // Dark mode toggle
        if (themeToggle) {
            let saved = localStorage.getItem('theme');
            if (!saved) {
                const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                saved = prefersDark ? 'dark' : 'light';
            }
            document.body.dataset.theme = saved;
            themeToggle.textContent = saved === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
            themeToggle.addEventListener('click', () => {
                const next = (document.body.dataset.theme === 'dark') ? 'light' : 'dark';
                document.body.dataset.theme = next;
                localStorage.setItem('theme', next);
                themeToggle.textContent = next === 'dark' ? 'â˜€ï¸' : 'ðŸŒ™';
            });
        }

        async function updateCliPreview() {
            if (!cliCommandEl) {
                return;
            }

            const inputText = document.getElementById('input-text').value.trim();
            const hasFile = fileInput && fileInput.files && fileInput.files.length > 0;
            const source = inputText ? 'text' : (hasFile ? 'file' : 'text');
            const locale = document.getElementById('locale').value;
            const cleanup = document.getElementById('cleanup').checked;
            const verbose = document.getElementById('verbose').checked;
            const outputFormat = document.getElementById('output-format').value;
            const pdfMode = document.getElementById('pdf-mode').value;
            const fontSize = parseInt(document.getElementById('font-size').value || '11', 10);
            const detectors = getSelectedDetectors();

            try {
                const resp = await fetch('/cli-preview', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        source,
                        locale: locale || null,
                        detectors,
                        cleanup,
                        verbose,
                        output_format: outputFormat,
                        pdf_mode: pdfMode,
                        font_size: fontSize,
                    }),
                });
                const data = await resp.json();
                if (resp.ok && data && data.command) {
                    cliCommandEl.textContent = data.command;
                } else {
                    cliCommandEl.textContent = 'sanitize-text -t <text>';
                }
            } catch (e) {
                cliCommandEl.textContent = 'sanitize-text -t <text>';
            }
        }

        // Drag & drop upload
        if (dropzone && fileInput && filePill) {
            function setFileInfo(file) {
                if (!file) { filePill.style.display = 'none'; filePill.textContent = ''; return; }
                filePill.style.display = 'inline-flex';
                filePill.textContent = file.name;
            }
            dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.classList.add('drag'); });
            dropzone.addEventListener('dragleave', () => dropzone.classList.remove('drag'));
            dropzone.addEventListener('drop', (e) => {
                e.preventDefault(); dropzone.classList.remove('drag');
                if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0]) {
                    fileInput.files = e.dataTransfer.files;
                    setFileInfo(fileInput.files[0]);
                }
            });
            dropzone.addEventListener('click', (e) => {
                const isLabel = e.target && e.target.tagName === 'LABEL';
                if (!isLabel) fileInput.click();
            });
            fileInput.addEventListener('change', () => {
                setFileInfo(fileInput.files[0]);
                void updateCliPreview();
            });
        }

        function getSelectedDetectors() {
            return Array.from(document.querySelectorAll('input[name="detector"]:checked'))
                .map(cb => cb.value);
        }

        function renderResultsIntoOutput(data) {
            const outputText = document.getElementById('output-text');
            const verboseDiv = document.getElementById('verbose-output');
            const verbosePanel = document.getElementById('verbose-panel');
            const meta = document.getElementById('result-meta');
            if (data.results) {
                const formattedText = data.results
                    .map(result => `[${result.locale}]\n${result.text}`)
                    .join('\n\n');
                outputText.value = formattedText;

                const verboseOn = document.getElementById('verbose').checked;
                if (verboseOn) {
                    const parts = data.results.map(r => {
                        if (!r.filth) return `[${r.locale}]\n(no filth details)`;
                        const lines = r.filth.map(f => `- ${f.type}: '${f.text}' -> '${f.replacement}'`);
                        return `[${r.locale}]\n` + lines.join('\n');
                    });
                    if (verbosePanel) verbosePanel.style.display = 'block';
                    verboseDiv.textContent = parts.join('\n\n');
                } else {
                    if (verbosePanel) verbosePanel.style.display = 'none';
                    verboseDiv.textContent = '';
                }
                if (meta) meta.textContent = `${data.results.length} locale(s)`;
            } else {
                outputText.value = 'No results returned';
                if (verbosePanel) verbosePanel.style.display = 'none';
                verboseDiv.textContent = '';
                if (meta) meta.textContent = '';
            }
        }

        const __procBtn = document.getElementById('process-btn');
        if (__procBtn) __procBtn.addEventListener('click', async () => {
            const inputText = document.getElementById('input-text').value;
            const locale = document.getElementById('locale').value;
            const processBtn = __procBtn;
            const outputText = document.getElementById('output-text');
            const custom = document.getElementById('custom-text').value || null;
            const cleanup = document.getElementById('cleanup').checked;
            const verbose = document.getElementById('verbose').checked;
            const selectedDetectors = getSelectedDetectors();
            
            try {
                processBtn.disabled = true;
                processBtn.textContent = 'Processing...';
                outputText.value = '';
                
                const response = await fetch('/process', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        text: inputText,
                        locale: locale || null,
                        detectors: selectedDetectors,
                        custom,
                        cleanup,
                        verbose
                    }),
                });
                
                const data = await response.json();
                if (response.ok) {
                    renderResultsIntoOutput(data);
                } else {
                    alert(data.error || 'Error processing text');
                }
            } catch (error) {
                alert('Error processing text. Please try again.');
            } finally {
                processBtn.disabled = false;
                processBtn.textContent = 'Process Text';
            }
        });

        const __procFileBtn = document.getElementById('process-file-btn');
        if (__procFileBtn) __procFileBtn.addEventListener('click', async () => {
            if (!fileInput.files || fileInput.files.length === 0) {
                alert('Please select a file to process.');
                return;
            }
            const locale = document.getElementById('locale').value;
            const custom = document.getElementById('custom-text').value || '';
            const cleanup = document.getElementById('cleanup').checked;
            const verbose = document.getElementById('verbose').checked;
            const selectedDetectors = getSelectedDetectors();

            const form = new FormData();
            form.append('file', fileInput.files[0]);
            if (locale) form.append('locale', locale);
            if (custom) form.append('custom', custom);
            form.append('cleanup', cleanup ? 'true' : 'false');
            form.append('verbose', verbose ? 'true' : 'false');
            selectedDetectors.forEach(d => form.append('detectors', d));

            try {
                const btn = __procFileBtn;
                btn.disabled = true;
                btn.textContent = 'Processing File...';
                const resp = await fetch('/process-file', { method: 'POST', body: form });
                const data = await resp.json();
                if (resp.ok) {
                    renderResultsIntoOutput(data);
                } else {
                    alert(data.error || 'Error processing file');
                }
            } catch (e) {
                alert('Error processing file. Please try again.');
            } finally {
                const btn = __procFileBtn;
                btn.disabled = false;
                btn.textContent = 'Process Uploaded File';
            }
        });

        async function triggerDownloadFromResponse(resp, fallbackName) {
            const blob = await resp.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            const cd = resp.headers.get('Content-Disposition') || '';
            const match = /filename\*=UTF-8''([^;]+)|filename="?([^";]+)"?/i.exec(cd);
            const headerName = match ? decodeURIComponent(match[1] || match[2]) : fallbackName;
            a.href = url;
            a.download = headerName || fallbackName;
            document.body.appendChild(a);
            a.click();
            a.remove();
            window.URL.revokeObjectURL(url);
        }

        const __dlTextBtn = document.getElementById('download-text-btn');
        if (__dlTextBtn) __dlTextBtn.addEventListener('click', async () => {
            const inputText = document.getElementById('input-text').value;
            if (!inputText) { alert('Please enter input text first.'); return; }
            const locale = document.getElementById('locale').value;
            const custom = document.getElementById('custom-text').value || null;
            const cleanup = document.getElementById('cleanup').checked;
            const outputFormat = document.getElementById('output-format').value;
            const pdfMode = document.getElementById('pdf-mode').value;
            const fontSize = parseInt(document.getElementById('font-size').value || '11', 10);
            const detectors = getSelectedDetectors();

            try {
                const btn = __dlTextBtn;
                btn.disabled = true;
                btn.textContent = 'Preparing Download...';
                const resp = await fetch('/export', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        text: inputText,
                        locale: locale || null,
                        detectors,
                        custom,
                        cleanup,
                        output_format: outputFormat,
                        pdf_mode: pdfMode,
                        font_size: fontSize,
                    }),
                });
                if (!resp.ok) {
                    let err = 'Download failed';
                    try { const j = await resp.json(); err = j.error || err; } catch {}
                    alert(err); return;
                }
                await triggerDownloadFromResponse(resp, `scrubbed.${outputFormat}`);
            } catch (e) {
                alert('Failed to prepare download.');
            } finally {
                const btn = __dlTextBtn;
                btn.disabled = false;
                btn.textContent = 'Download From Text';
            }
        });

        const __dlFileBtn = document.getElementById('download-file-btn');
        if (__dlFileBtn) __dlFileBtn.addEventListener('click', async () => {
            if (!fileInput.files || fileInput.files.length === 0) {
                alert('Please select a file to download results for.');
                return;
            }
            const locale = document.getElementById('locale').value;
            const custom = document.getElementById('custom-text').value || '';
            const cleanup = document.getElementById('cleanup').checked;
            const outputFormat = document.getElementById('output-format').value;
            const pdfMode = document.getElementById('pdf-mode').value;
            const fontSize = document.getElementById('font-size').value || '11';
            const detectors = getSelectedDetectors();

            const form = new FormData();
            form.append('file', fileInput.files[0]);
            if (locale) form.append('locale', locale);
            if (custom) form.append('custom', custom);
            form.append('cleanup', cleanup ? 'true' : 'false');
            form.append('output_format', outputFormat);
            form.append('pdf_mode', pdfMode);
            form.append('font_size', String(fontSize));
            detectors.forEach(d => form.append('detectors', d));

            try {
                const btn = __dlFileBtn;
                btn.disabled = true;
                btn.textContent = 'Preparing Download...';
                const resp = await fetch('/download-file', { method: 'POST', body: form });
                if (!resp.ok) {
                    let err = 'Download failed';
                    try { const j = await resp.json(); err = j.error || err; } catch {}
                    alert(err); return;
                }
                await triggerDownloadFromResponse(resp, `scrubbed.${outputFormat}`);
            } catch (e) {
                alert('Failed to prepare download.');
            } finally {
                const btn = __dlFileBtn;
                btn.disabled = false;
                btn.textContent = 'Download From File';
            }
        });

        // Unified new actions
        const scrubBtn = document.getElementById('scrub-btn');
        if (scrubBtn) scrubBtn.addEventListener('click', async () => {
            const inputText = document.getElementById('input-text').value.trim();
            const locale = document.getElementById('locale').value;
            const custom = document.getElementById('custom-text').value || null;
            const cleanup = document.getElementById('cleanup').checked;
            const verbose = document.getElementById('verbose').checked;
            const selectedDetectors = getSelectedDetectors();
            const outputText = document.getElementById('output-text');
            try {
                scrubBtn.disabled = true;
                scrubBtn.textContent = 'Scrubbingâ€¦';
                outputText.value = '';
                if (inputText) {
                    const r = await fetch('/process', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: inputText, locale: locale || null, detectors: selectedDetectors, custom, cleanup, verbose }) });
                    const data = await r.json();
                    if (r.ok) renderResultsIntoOutput(data); else alert(data.error || 'Error processing text');
                } else if (fileInput && fileInput.files && fileInput.files.length > 0) {
                    const form = new FormData();
                    form.append('file', fileInput.files[0]);
                    if (locale) form.append('locale', locale);
                    if (custom) form.append('custom', custom);
                    form.append('cleanup', cleanup ? 'true' : 'false');
                    form.append('verbose', verbose ? 'true' : 'false');
                    selectedDetectors.forEach(d => form.append('detectors', d));
                    const r = await fetch('/process-file', { method: 'POST', body: form });
                    const data = await r.json();
                    if (r.ok) renderResultsIntoOutput(data); else alert(data.error || 'Error processing file');
                } else {
                    alert('Enter text or choose a file first.');
                }
            } catch (e) {
                alert('Scrub failed. Please try again.');
            } finally {
                scrubBtn.disabled = false;
                scrubBtn.textContent = 'Scrub';
            }
        });

        const downloadBtn = document.getElementById('download-btn');
        if (downloadBtn) downloadBtn.addEventListener('click', async () => {
            const inputText = document.getElementById('input-text').value.trim();
            const locale = document.getElementById('locale').value;
            const custom = document.getElementById('custom-text').value || null;
            const cleanup = document.getElementById('cleanup').checked;
            const outputFormat = document.getElementById('output-format').value;
            const pdfMode = document.getElementById('pdf-mode').value;
            const fontSize = parseInt(document.getElementById('font-size').value || '11', 10);
            const detectors = getSelectedDetectors();
            try {
                downloadBtn.disabled = true;
                downloadBtn.textContent = 'Preparingâ€¦';
                if (inputText) {
                    const resp = await fetch('/export', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ text: inputText, locale: locale || null, detectors, custom, cleanup, output_format: outputFormat, pdf_mode: pdfMode, font_size: fontSize }) });
                    if (!resp.ok) { let err = 'Download failed'; try { const j = await resp.json(); err = j.error || err; } catch {} alert(err); } else { await triggerDownloadFromResponse(resp, `scrubbed.${outputFormat}`); }
                } else if (fileInput && fileInput.files && fileInput.files.length > 0) {
                    const form = new FormData();
                    form.append('file', fileInput.files[0]);
                    if (locale) form.append('locale', locale);
                    if (custom) form.append('custom', custom);
                    form.append('cleanup', cleanup ? 'true' : 'false');
                    form.append('output_format', outputFormat);
                    form.append('pdf_mode', pdfMode);
                    form.append('font_size', String(fontSize));
                    detectors.forEach(d => form.append('detectors', d));
                    const resp = await fetch('/download-file', { method: 'POST', body: form });
                    if (!resp.ok) { let err = 'Download failed'; try { const j = await resp.json(); err = j.error || err; } catch {} alert(err); } else { await triggerDownloadFromResponse(resp, `scrubbed.${outputFormat}`); }
                } else {
                    alert('Enter text or choose a file first.');
                }
            } catch (e) {
                alert('Failed to prepare download.');
            } finally {
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'Download';
            }
        });

        document.getElementById('copy-btn').addEventListener('click', () => {
            const outputText = document.getElementById('output-text');
            outputText.select();
            document.execCommand('copy');
            
            const copyBtn = document.getElementById('copy-btn');
            const originalText = copyBtn.textContent;
            copyBtn.textContent = 'Copied!';
            
            setTimeout(() => {
                copyBtn.textContent = originalText;
            }, 2000);
        });

        if (cliCopyBtn && cliCommandEl) {
            cliCopyBtn.addEventListener('click', () => {
                const command = cliCommandEl.textContent || '';
                if (!navigator.clipboard) {
                    const tmp = document.createElement('textarea');
                    tmp.value = command;
                    document.body.appendChild(tmp);
                    tmp.select();
                    document.execCommand('copy');
                    tmp.remove();
                } else {
                    navigator.clipboard.writeText(command).catch(() => {});
                }

                const original = cliCopyBtn.textContent;
                cliCopyBtn.textContent = 'Copied!';
                setTimeout(() => {
                    cliCopyBtn.textContent = original;
                }, 2000);
            });
        }

        // Keep CLI preview roughly in sync with configuration changes
        ['input-text', 'custom-text', 'cleanup', 'verbose', 'output-format', 'pdf-mode', 'font-size'].forEach((id) => {
            const el = document.getElementById(id);
            if (!el) return;
            const evt = (el.tagName === 'TEXTAREA' || el.tagName === 'INPUT') ? 'input' : 'change';
            el.addEventListener(evt, () => { void updateCliPreview(); });
        });
        document.querySelectorAll('input[name="detector"]').forEach((cb) => {
            cb.addEventListener('change', () => { void updateCliPreview(); });
        });

        void updateCliPreview();
    </script>

    <style>
        .controls-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin: 1rem 0;
        }

        .step-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted-text);
            margin-bottom: 0.35rem;
        }

        .step-label-sub {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .locale-selector {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .locale-selector select {
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            font-size: 1rem;
            background-color: var(--surface-color);
            color: var(--text-color);
        }

        .locale-selector label {
            font-weight: bold;
        }

        .cli-preview {
            margin-top: 0.75rem;
            padding: 0.75rem 0.85rem;
            border-radius: 0.5rem;
            border: 1px solid var(--border-color);
            background-color: var(--surface-color);
        }

        .cli-preview-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 0.35rem;
        }

        .cli-preview-title {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--muted-text);
        }

        .cli-command {
            margin: 0;
            padding: 0.45rem 0.6rem;
            border-radius: 0.4rem;
            background-color: rgba(15, 23, 42, 0.8);
            color: #e5e7eb;
            font-size: 0.85rem;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            white-space: pre;
            overflow-x: auto;
        }

        .ghost-button {
            border-radius: 9999px;
            border: 1px solid var(--border-color);
            background: transparent;
            color: var(--text-color);
            padding: 0.25rem 0.75rem;
            font-size: 0.8rem;
            cursor: pointer;
        }

        .detector-options {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            padding: 1rem;
            border: 1px solid var(--border-color);
            border-radius: 0.5rem;
            background-color: var(--surface-color);
        }

        .detector-note {
            width: 100%;
            margin: 0;
            font-size: 0.9rem;
            color: var(--muted-text);
        }

        .detector-group {
            min-width: 200px;
        }

        .detector-group h3 {
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
            color: var(--text-color);
        }

        .detector-list {
            display: flex;
            flex-direction: column;
            gap: 0.3rem;
        }

        .detector-list label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
        }

        .detector-list input[type="checkbox"] {
            margin: 0;
        }

        .extra-options { display: flex; flex-direction: column; gap: 0.75rem; }
        .field { display: flex; flex-direction: column; gap: 0.25rem; }
        .field-row { display: flex; flex-wrap: wrap; gap: 1rem; align-items: center; }
        .field-row select, .field-row input[type="number"], .extra-options input[type="text"] {
            padding: 0.5rem; border: 1px solid var(--border-color); border-radius: 0.5rem; font-size: 1rem; background-color: var(--surface-color); color: var(--text-color);
        }
        .toggle { display: inline-flex; align-items: center; gap: 0.5rem; }
        .upload-container { display: flex; flex-direction: column; gap: 0.25rem; }
        .button-row { display: flex; flex-wrap: wrap; gap: 0.5rem; justify-content: flex-end; }
        #process-btn {
            align-self: flex-end;
        }
    </style>
</body>
</html>